<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【瞎折腾向】Windows-Kali双系统安装笔记</title>
    <url>/blog/2020/03/16/kali_install/</url>
    <content><![CDATA[<h1>【瞎折腾向】Windows-Kali双系统安装笔记</h1>
<p>最近因为被某同学怂恿<a href="https://fa555.github.io/" target="_blank" rel="noopener">@fa555</a>装了Ubuntu18和win10的双系统，但不知为何一直无法使用无线网卡，所以就一直搁置在那里。然后近日突然想搞个Kali玩玩于是准备用Kali替换掉Ubuntu18，现在把过程记录在这里。<a id="more"></a></p>
<h2 id="Kali简介"><a class="header-anchor" href="#Kali简介">♔</a>Kali简介</h2>
<p>Kali Linux是基于<a href="https://baike.baidu.com/item/Debian/748667" target="_blank" rel="noopener">Debian</a>的Linux发行版， 设计用于数字取证操作系统。由Offensive Security Ltd维护和资助。最先由Offensive Security的Mati Aharoni和Devon Kearns通过重写BackTrack来完成，BackTrack是他们之前写的用于取证的Linux发行版 。</p>
<p>Kali Linux预装了许多渗透测试软件，包括nmap 、Wireshark 、John the Ripper，以及Aircrack-ng.[2] 用户可通过硬盘、live CD或live USB运行Kali Linux。Kali Linux既有32位和64位的镜像。可用于x86 指令集。同时还有基于ARM架构的镜像，可用于树莓派和三星的ARM Chromebook。</p>
<h2 id="安装前必要的操作"><a class="header-anchor" href="#安装前必要的操作">♔</a>安装前必要的操作</h2>
<p>1.分一个存储空间给kali</p>
<p>2.一个8G及以上的U盘</p>
<p>3.安装软碟通或Win32DiskImager</p>
<p>4.下载kali镜像</p>
<h2 id="给kali分配存储空间"><a class="header-anchor" href="#给kali分配存储空间">♔</a>给kali分配存储空间</h2>
<p>因为我是<strong>双硬盘</strong>，所以先在C盘（按理来说就是电脑的第一块硬盘，部分电脑系统装得比较奇怪，装到了第二块硬盘）分出200M的空白分区用来安装ubuntu的启动项，然后再在另一块硬盘选择最后一个盘（比如 CD两个盘的最后一个是D盘，CDE盘的最后一个是E盘，CDEF盘的最后一个是F盘，以此类推），在该盘点击右键，选择压缩卷，如下，输入压缩空间量，单位为M,如果空间充足，建议分出80G或100G，空间不足也可以分60G（1G=1024M）</p>
<p><img src="https://img2018.cnblogs.com/blog/1628751/201905/1628751-20190510155645369-1469851559.png" alt="img"></p>
<h2 id="制作kali启动盘"><a class="header-anchor" href="#制作kali启动盘">♔</a>制作kali启动盘</h2>
<h3 id="使用软碟通"><a class="header-anchor" href="#使用软碟通">♔</a>使用软碟通</h3>
<p>选择放有iso文件的文件夹</p>
<p>双击iso文件</p>
<p>点击启动，选择写入硬盘映像</p>
<p><img src="https://upload-images.jianshu.io/upload_images/15630102-909c2f49ffc88d5f.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/770/format/webp" alt="img"></p>
<p>这里要将写入方式改为<strong>raw</strong>，然后点击写入即可(如果写入后出现是否格式化U盘，一定不要点，不然就白做了)</p>
<p><img src="https://upload-images.jianshu.io/upload_images/15630102-b11ce35ba65fdb31.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/540/format/webp" alt="img"></p>
<h2 id="进入BIOS关闭SecureBoot"><a class="header-anchor" href="#进入BIOS关闭SecureBoot">♔</a>进入BIOS关闭SecureBoot</h2>
<p><img src="https://upload-images.jianshu.io/upload_images/15630102-8965f09212ed7539.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/712/format/webp" alt="img"></p>
<p>然后重启电脑选择U盘启动。</p>
<h2 id="安装kali"><a class="header-anchor" href="#安装kali">♔</a>安装kali</h2>
<p>选择start installer,语言选中文，然后配置网卡（为了方便可以不先配置），然后设置主机名，域名(默认，空着就行了)，root密码等等。</p>
<p>然后<strong>选择手动分区</strong>，你可以看到两个空闲分区，其中一个大小是你分区时给定的；另一个空闲分区，大小200M左右</p>
<p>在这里，我们进行手动分区，假设你留出的空闲分区为 80G，点击空闲盘符，点击&quot;+&quot;进行分区，如下：</p>
<p>1）efi：因为我是<strong>双硬盘</strong>，找到事先分好的200M空闲分区添加，逻辑分区，空间起始位置，用于efi。这个分区必不可少，用于安装ubuntu启动项。以下步骤都在那个80G的空闲分区上添加</p>
<p>2）swap:中文是&quot;交换空间&quot;，充当ubuntu的虚拟内存，一般的大小为电脑物理内存的2倍左右，可以将其分为 16G，逻辑分区，空间起始位置，用于&quot;swap&quot;或&quot;交换空间&quot;</p>
<ol start="3">
<li>/:这是ubuntu 的根目录,用于安装系统和软件，相当于windows的C盘，我们将其分为 20G，主分区，空间起始位置，用于&quot;ext4日志文件系统&quot;，挂载点为&quot;/&quot;（根据你的磁盘空间调整，可以大一点，毕竟ubuntu装软件都是默认装在根目录的）</li>
</ol>
<p>4）/home:相当于windows的其他盘，剩下的全分给它，逻辑分区，空间起始位置，用于&quot;ext4日志文件系统&quot;，挂载点为&quot;/home&quot;</p>
<p><img src="https://upload-images.jianshu.io/upload_images/15630102-55ad985475b4969d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/628/format/webp" alt="img"></p>
<p>至此分区结束，然后等待安装完成后自动重启，选择kali启动就可以进入系统了。</p>
<h2 id="参考文献"><a class="header-anchor" href="#参考文献">♔</a>参考文献</h2>
<p><a href="https://www.jianshu.com/p/6d90d8084128" target="_blank" rel="noopener">Windows-Kali双系统安装教程</a></p>
<p><a href="https://www.cnblogs.com/masbay/p/11627727.html" target="_blank" rel="noopener">Windows10安装ubuntu18.04双系统教程</a></p>
]]></content>
      <categories>
        <category>瞎折腾</category>
        <category>双系统</category>
        <category>Kali Linux</category>
      </categories>
      <tags>
        <tag>瞎折腾</tag>
        <tag>双系统</tag>
        <tag>Kali</tag>
        <tag>Linux</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF CSP 201412-3 集合竞价</title>
    <url>/blog/2020/02/12/csp201412-3/</url>
    <content><![CDATA[<h1>CCF CSP 201412-3 集合竞价</h1>
<h2 id="问题描述"><a class="header-anchor" href="#问题描述">♔</a>问题描述</h2>
<p>某股票交易所请你编写一个程序，根据开盘前客户提交的订单来确定某特定股票的开盘价和开盘成交量。<br>
　　该程序的输入由很多行构成，每一行为一条记录，记录可能有以下几种：<br>
　　1. buy p s 表示一个购买股票的买单，每手出价为p，购买股数为s。<br>
　　2. sell p s 表示一个出售股票的卖单，每手出价为p，出售股数为s。<br>
　　3. cancel i表示撤销第i行的记录。<br>
　　如果开盘价为p0，则系统可以将所有出价至少为p0的买单和所有出价至多为p0的卖单进行匹配。因此，此时的开盘成交量为出价至少为p0的买单的总股数和所有出价至多为p0的卖单的总股数之间的较小值。<br>
　　你的程序需要确定一个开盘价，使得开盘成交量尽可能地大。如果有多个符合条件的开盘价，你的程序应当输出最高的那一个。<a id="more"></a></p>
<h2 id="输入格式"><a class="header-anchor" href="#输入格式">♔</a>输入格式</h2>
<p>输入数据有任意多行，每一行是一条记录。保证输入合法。股数为不超过108的正整数，出价为精确到恰好小数点后两位的正实数，且不超过10000.00。</p>
<h2 id="输出格式"><a class="header-anchor" href="#输出格式">♔</a>输出格式</h2>
<p>你需要输出一行，包含两个数，以一个空格分隔。第一个数是开盘价，第二个是此开盘价下的成交量。开盘价需要精确到小数点后恰好两位。</p>
<h2 id="样例输入"><a class="header-anchor" href="#样例输入">♔</a>样例输入</h2>
<p>buy 9.25 100<br>
buy 8.88 175<br>
sell 9.00 1000<br>
buy 9.00 400<br>
sell 8.92 400<br>
cancel 1<br>
buy 100.00 50</p>
<h2 id="样例输出"><a class="header-anchor" href="#样例输出">♔</a>样例输出</h2>
<p>9.00 450</p>
<h2 id="评测用例规模与约定"><a class="header-anchor" href="#评测用例规模与约定">♔</a>评测用例规模与约定</h2>
<p>对于100%的数据，输入的行数不超过5000。</p>
<h2 id="解题思路"><a class="header-anchor" href="#解题思路">♔</a>解题思路</h2>
<p>​		根据题意可知，我们要求的是使成交量最大的最高的价格，借鉴<a href="https://blog.csdn.net/more_ugly_less_bug/article/details/60147075" target="_blank" rel="noopener">博客</a>的证明可知开盘价一定是输入的p中。为什么呢，将测试案例按p从小到大排列开，如下图所示。图示中各价格用序号标识好，方便说明。</p>
<p><img src="https://img-blog.csdn.net/20170303205948247?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbW9yZV91Z2x5X2xlc3NfYnVn/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>​		（下述最优解意思是可以取到最大开盘价的解）</p>
<p>​		假设(8.92,9.00)区间（注意是开区间）内某一点p是最优价格，那么大于或等于这个价格的buy点有3、5，小于等于它的sell点有2，那么不管p在区间(8.92,9.00)内怎么浮动，都不影响大于它的sell点和小于它的buy点的选择，都是点2和点3、5。题目要求取最大值，所以在假设在(2,3)区间存在最优价格的情况下，取值可以无限逼近与9.00。</p>
<p>​		当价格9.00存在sell点时，值取到9.00显然不会改变原有的buy、sell点的选择。</p>
<p>​		当9.00存在sell点时，取9.00将会影响buy、sell点的选择。在趋于9.00时，设sell的总股数为a，buy的总股数为b。取到9.00时.设sell的总股数为a+c，buy的总股数为b，很容易明白min(a,b) &lt;= min(a+c,b)，即在9.00存在sell点时，得到的结果总会优于趋近于9.00却没有取9.00上的sell点的情况。推广开来，我们可以知道，假设两个点的区间(a,b]上存在最优解，那么b一定也是最优解，且b是最大的，所以b是答案。所以答案一定是存在于已知的点上 。</p>
<p>​		（又及，十年oi一场空，不开long long见祖宗</p>
<h2 id="代码"><a class="header-anchor" href="#代码">♔</a>代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ll sum,flag;</span><br><span class="line">	<span class="keyword">double</span> price; </span><br><span class="line">&#125;tic[<span class="number">5005</span>];</span><br><span class="line"><span class="built_in">string</span> a;</span><br><span class="line">ll n,alls,allb,maxs;</span><br><span class="line"><span class="keyword">double</span> maxp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wly</span><span class="params">(data a,data b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.price&gt;b.price) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(a.price==b.price &amp;&amp; a.flag&lt;b.flag) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	i=<span class="number">1</span>;n=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a)</span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="keyword">if</span>(a==<span class="string">"buy"</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;tic[i].price;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;tic[i].sum;</span><br><span class="line">			tic[i].flag=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="string">"sell"</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;tic[i].price;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;tic[i].sum;</span><br><span class="line">			tic[i].flag=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="string">"cancel"</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;j;</span><br><span class="line">			tic[j].price=<span class="number">0.0</span>;</span><br><span class="line">			tic[j].sum=<span class="number">0</span>;</span><br><span class="line">			n--;</span><br><span class="line">		&#125;</span><br><span class="line">		i++;n++;</span><br><span class="line">	&#125;</span><br><span class="line">	n--;</span><br><span class="line">	sort(tic+<span class="number">1</span>,tic+i,wly);</span><br><span class="line">	<span class="comment">//printf("%d %d\n",i,n);</span></span><br><span class="line">	<span class="comment">//for(i=1;i&lt;=n;i++) </span></span><br><span class="line">	<span class="comment">//	printf("%d %lf %d\n",tic[i].sum,tic[i].price,tic[i].flag);</span></span><br><span class="line">	j=n;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=j;i++)	</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(tic[i].price==tic[i<span class="number">-1</span>].price &amp;&amp; tic[i].flag==tic[i<span class="number">-1</span>].flag)</span><br><span class="line">		&#123;</span><br><span class="line">			tic[i].sum+=tic[i<span class="number">-1</span>].sum;</span><br><span class="line">			tic[i<span class="number">-1</span>].flag=<span class="number">0</span>;tic[i<span class="number">-1</span>].price=<span class="number">0.0</span>;tic[i<span class="number">-1</span>].flag=<span class="number">0</span>;</span><br><span class="line">			n--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	sort(tic+<span class="number">1</span>,tic+i,wly);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) alls+=tic[i].flag*tic[i].sum;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//printf("-%d %d-\n",alls,allb);</span></span><br><span class="line">		<span class="keyword">if</span>(tic[i].flag)</span><br><span class="line">		&#123;</span><br><span class="line">			alls-=tic[i].sum;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		allb+=tic[i].sum;</span><br><span class="line">		<span class="keyword">if</span>(maxs&lt;min(alls,allb))</span><br><span class="line">		&#123;</span><br><span class="line">			maxs=min(alls,allb);</span><br><span class="line">			maxp=tic[i].price;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//for(i=1;i&lt;=n;i++) </span></span><br><span class="line">	<span class="comment">//	printf("%d %lf %d\n",tic[i].sum,tic[i].price,tic[i].flag);</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.2lf %lld"</span>,maxp,maxs);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
        <category>csp</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>csp</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF CSP 201403-4 无线网络</title>
    <url>/blog/2020/02/12/csp201403-4%20/</url>
    <content><![CDATA[<h1>CCF CSP 201403-4 无线网络</h1>
<h2 id="问题描述"><a class="header-anchor" href="#问题描述">♔</a>问题描述</h2>
<p>目前在一个很大的平面房间里有 n 个无线路由器,每个无线路由器都固定在某个点上。任何两个无线路由器只要距离不超过 r 就能互相建立网络连接。<br>
　　除此以外,另有 m 个可以摆放无线路由器的位置。你可以在这些位置中选择至多 k 个增设新的路由器。<br>
　　你的目标是使得第 1 个路由器和第 2 个路由器之间的网络连接经过尽量少的中转路由器。请问在最优方案下中转路由器的最少个数是多少?<a id="more"></a></p>
<h2 id="输入格式"><a class="header-anchor" href="#输入格式">♔</a>输入格式</h2>
<p>第一行包含四个正整数 n,m,k,r。(2 ≤ n ≤ 100,1 ≤ k ≤ m ≤ 100, 1 ≤ r ≤ 108)。<br>
　　接下来 n 行,每行包含两个整数 xi 和 yi,表示一个已经放置好的无线 路由器在 (xi, yi) 点处。输入数据保证第 1 和第 2 个路由器在仅有这 n 个路由器的情况下已经可以互相连接(经过一系列的中转路由器)。<br>
　　接下来 m 行,每行包含两个整数 xi 和 yi,表示 (xi, yi) 点处可以增设 一个路由器。<br>
　　输入中所有的坐标的绝对值不超过 108,保证输入中的坐标各不相同。</p>
<h2 id="输出格式"><a class="header-anchor" href="#输出格式">♔</a>输出格式</h2>
<p>输出只有一个数,即在指定的位置中增设 k 个路由器后,从第 1 个路 由器到第 2 个路由器最少经过的中转路由器的个数。</p>
<h2 id="样例输入"><a class="header-anchor" href="#样例输入">♔</a>样例输入</h2>
<p>5 3 1 3<br>
0 0<br>
5 5<br>
0 3<br>
0 5<br>
3 5<br>
3 3<br>
4 4<br>
3 0</p>
<h2 id="样例输出"><a class="header-anchor" href="#样例输出">♔</a>样例输出</h2>
<p>2</p>
<h2 id="解题思路"><a class="header-anchor" href="#解题思路">♔</a>解题思路</h2>
<p>​		根据题意可知，若把距离小于等于r的两路由器视为存在一条边，则题目转化为为求无权无向图的最短路径。这里用spfa跑一遍，在跑的过程中注意已经添加的路由器的个数，若已经达到上限则不再添加。又因为是求中转点的个数，故将最后求得的最短路-1，从而减去终点，求得中转点的个数。</p>
<p>​		（又及好像可以用分层图做，改天学一下</p>
<p>​		（又及的又及，经❤️帅气的小天天❤️提醒，这一题边数最多可以到达n^2，我数组开小了😓</p>
<h2 id="代码"><a class="header-anchor" href="#代码">♔</a>代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ll x,y;</span><br><span class="line">&#125;po[<span class="number">20005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> i,k;</span><br><span class="line">&#125;;</span><br><span class="line">ll r;</span><br><span class="line"><span class="keyword">int</span> n,m,k,ecnt;</span><br><span class="line"><span class="keyword">int</span> adj[<span class="number">20005</span>],nxt[<span class="number">40005</span>],too[<span class="number">40005</span>],dis[<span class="number">20005</span>],visit[<span class="number">20005</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%lld"</span>,&amp;n,&amp;m,&amp;k,&amp;r);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n+m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;po[i].x,&amp;po[i].y);</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(((po[i].x-po[j].x)*(po[i].x-po[j].x))+((po[i].y-po[j].y)*(po[i].y-po[j].y))&lt;=r*r)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//printf("-%d %d-\n",i,j);</span></span><br><span class="line">				nxt[++ecnt]=adj[i],adj[i]=ecnt,too[ecnt]=j;</span><br><span class="line">				nxt[++ecnt]=adj[j],adj[j]=ecnt,too[ecnt]=i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n+m;i++) dis[i]=<span class="number">2147483647</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;data2&gt; q;</span><br><span class="line">	data2 s;</span><br><span class="line">	s.i=<span class="number">1</span>,s.k=<span class="number">0</span>;</span><br><span class="line">	q.push(s);</span><br><span class="line">	dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	visit[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	data2 v,u;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		u=q.front();</span><br><span class="line">		<span class="comment">//printf("%d %d\n",u.i,u.k);</span></span><br><span class="line">		q.pop();</span><br><span class="line">		visit[u.i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=adj[u.i];i;i=nxt[i])</span><br><span class="line">		&#123;</span><br><span class="line">			v.i=too[i];</span><br><span class="line">			<span class="comment">//printf("-%d %d %d %d %d-\n",u.i,v.i,dis[u.i],dis[v.i],u.k);</span></span><br><span class="line">			<span class="keyword">if</span>(v.i&gt;n &amp;&amp; u.k&gt;=k) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(dis[v.i]&gt;dis[u.i]+<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				dis[v.i]=dis[u.i]+<span class="number">1</span>;</span><br><span class="line">				<span class="comment">//printf("+%d %d %d %d %d+\n",u.i,v.i,dis[u.i],dis[v.i],u.k);</span></span><br><span class="line">				<span class="keyword">if</span>(!visit[v.i])</span><br><span class="line">				&#123;</span><br><span class="line">					v.k=u.k;</span><br><span class="line">					<span class="keyword">if</span>(v.i&gt;n) v.k+=<span class="number">1</span>;</span><br><span class="line">					q.push(v);</span><br><span class="line">					visit[v.i]=<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,dis[<span class="number">2</span>]<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
        <category>csp</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>csp</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>spfa</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF CSP 201409-4 送货</title>
    <url>/blog/2020/02/12/csp201512-4/</url>
    <content><![CDATA[<h1>CCF CSP 201512-4 送货</h1>
<h2 id="问题描述"><a class="header-anchor" href="#问题描述">♔</a>问题描述</h2>
<p>为了增加公司收入，F公司新开设了物流业务。由于F公司在业界的良好口碑，物流业务一开通即受到了消费者的欢迎，物流业务马上遍及了城市的每条街道。然而，F公司现在只安排了小明一个人负责所有街道的服务。<br>
　　任务虽然繁重，但是小明有足够的信心，他拿到了城市的地图，准备研究最好的方案。城市中有<em>n</em>个交叉路口，<em>m</em>条街道连接在这些交叉路口之间，每条街道的首尾都正好连接着一个交叉路口。除开街道的首尾端点，街道不会在其他位置与其他街道相交。每个交叉路口都至少连接着一条街道，有的交叉路口可能只连接着一条或两条街道。<br>
　　小明希望设计一个方案，从编号为1的交叉路口出发，每次必须沿街道去往街道另一端的路口，再从新的路口出发去往下一个路口，直到所有的街道都经过了正好一次。<a id="more"></a></p>
<h2 id="输入格式"><a class="header-anchor" href="#输入格式">♔</a>输入格式</h2>
<p>输入的第一行包含两个整数<em>n</em>, <em>m</em>，表示交叉路口的数量和街道的数量，交叉路口从1到<em>n</em>标号。<br>
　　接下来<em>m</em>行，每行两个整数<em>a</em>, <em>b</em>，表示和标号为<em>a</em>的交叉路口和标号为<em>b</em>的交叉路口之间有一条街道，街道是双向的，小明可以从任意一端走向另一端。两个路口之间最多有一条街道。</p>
<h2 id="输出格式"><a class="header-anchor" href="#输出格式">♔</a>输出格式</h2>
<p>如果小明可以经过每条街道正好一次，则输出一行包含<em>m</em>+1个整数<em>p</em>1, <em>p</em>2, <em>p</em>3, …, <em>pm</em>+1，表示小明经过的路口的顺序，相邻两个整数之间用一个空格分隔。如果有多种方案满足条件，则输出字典序最小的一种方案，即首先保证<em>p</em>1最小，<em>p</em>1最小的前提下再保证<em>p</em>2最小，依此类推。<br>
　　如果不存在方案使得小明经过每条街道正好一次，则输出一个整数-1。</p>
<h2 id="样例输入"><a class="header-anchor" href="#样例输入">♔</a>样例输入</h2>
<p>4 5<br>
1 2<br>
1 3<br>
1 4<br>
2 4<br>
3 4</p>
<h2 id="样例输出"><a class="header-anchor" href="#样例输出">♔</a>样例输出</h2>
<p>1 2 4 1 3 4</p>
<h2 id="样例说明"><a class="header-anchor" href="#样例说明">♔</a>样例说明</h2>
<p>城市的地图和小明的路径如下图所示。</p>
<p><img src="http://118.190.20.162/RequireFile.do?fid=HgNYQ5G9" alt="img"></p>
<h2 id="样例输入-v2"><a class="header-anchor" href="#样例输入-v2">♔</a>样例输入</h2>
<p>4 6<br>
1 2<br>
1 3<br>
1 4<br>
2 4<br>
3 4<br>
2 3</p>
<h2 id="样例输出-v2"><a class="header-anchor" href="#样例输出-v2">♔</a>样例输出</h2>
<p>-1</p>
<h2 id="样例说明-v2"><a class="header-anchor" href="#样例说明-v2">♔</a>样例说明</h2>
<p>城市的地图如下图所示，不存在满足条件的路径。</p>
<p><img src="http://118.190.20.162/RequireFile.do?fid=67NLAqAY" alt="img"></p>
<h2 id="评测用例规模与约定"><a class="header-anchor" href="#评测用例规模与约定">♔</a>评测用例规模与约定</h2>
<p>前30%的评测用例满足：1 ≤ <em>n</em> ≤ 10, <em>n</em>-1 ≤ <em>m</em> ≤ 20。<br>
　　前50%的评测用例满足：1 ≤ <em>n</em> ≤ 100, <em>n</em>-1 ≤ <em>m</em> ≤ 10000。<br>
　　所有评测用例满足：1 ≤ <em>n</em> ≤ 10000，<em>n</em>-1 ≤ <em>m</em> ≤ 100000。</p>
<h2 id="解题思路"><a class="header-anchor" href="#解题思路">♔</a>解题思路</h2>
<p>​		根据题意可知，这一题要首先要判断图是否联通，然后再判断图中是否存在欧拉路径或欧拉回路，即要么图中只有两个度数为奇数的点且编号为1的顶点的度数为奇数，要么没有度数为奇数的点。确定好之后通过dfs寻找路径即可。需要注意的是直接搜索的话会爆栈，只能得80分，那么我们就需要用手工栈来模拟dfs，这样就可以a掉了。</p>
<p>​		以及，根据这个<a href="https://blog.csdn.net/more_ugly_less_bug/article/details/60962425" target="_blank" rel="noopener">博客</a>所说，我们需要在递归回来之后才将该节点添加入栈，相当于倒序储存。一般情况下和用队列顺序存储差别不大。但是有一种存在孤点的图。如下图所示：</p>
<p><img src="https://img-blog.csdn.net/20170309165411115" alt="img"></p>
<p>图中点2 是孤立点，如果每次搜索到一个节点就存储进队列的话，就会出现错误，而用栈倒序存储就能解决这个问题。</p>
<h2 id="代码"><a class="header-anchor" href="#代码">♔</a>代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> lu[<span class="number">1000005</span>],d[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">bool</span> tu[<span class="number">10005</span>][<span class="number">10005</span>],visit[<span class="number">100005</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; po[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> dsum,s1,s2;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">//	if(dsum==m+1)</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		for(i=1;i&lt;=dsum;i++)</span></span><br><span class="line"><span class="comment">//			printf("%d ",lu[i]);</span></span><br><span class="line"><span class="comment">//		exit(0);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;po[x].size();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(tu[x][po[x][i]])</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">			tu[x][po[x][i]]=<span class="number">0</span>;</span><br><span class="line">			tu[po[x][i]][x]=<span class="number">0</span>;</span><br><span class="line">			dfs(po[x][i]);</span><br><span class="line">			<span class="comment">//tu[x][po[x][i]]=1;</span></span><br><span class="line">			<span class="comment">//tu[po[x][i]][x]=1;</span></span><br><span class="line">			<span class="comment">//dsum--;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	lu[++dsum]=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;po[x].size();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!visit[po[x][i]])</span><br><span class="line">		&#123;</span><br><span class="line">			visit[po[x][i]]=<span class="number">1</span>;</span><br><span class="line">			make(po[x][i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,k;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;j,&amp;k);</span><br><span class="line">		tu[j][k]=<span class="number">1</span>;</span><br><span class="line">		tu[k][j]=<span class="number">1</span>;</span><br><span class="line">		po[j].push_back(k);</span><br><span class="line">		po[k].push_back(j);</span><br><span class="line">		d[j]++,d[k]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sort(po[i].begin(),po[i].end());</span><br><span class="line">		<span class="keyword">if</span>(d[i]%<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(dsum==<span class="number">2</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!dsum)</span><br><span class="line">				s1=i;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				s2=i;</span><br><span class="line">			dsum++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dsum==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!dsum) s1=s2=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(dsum==<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(s1&gt;s2) swap(s1,s2); </span><br><span class="line">		<span class="keyword">if</span>(s1!=<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	visit[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	make(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!visit[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dsum=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//lu[dsum]=s1;</span></span><br><span class="line">	<span class="comment">//dfs(s1);</span></span><br><span class="line">	st.push(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(!st.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x=st.top();</span><br><span class="line">		<span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;po[x].size();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(tu[x][po[x][i]])</span><br><span class="line">			&#123;</span><br><span class="line">				tu[x][po[x][i]]=<span class="number">0</span>;</span><br><span class="line">				tu[po[x][i]][x]=<span class="number">0</span>;</span><br><span class="line">				st.push(po[x][i]);</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag==<span class="number">0</span>) lu[++dsum]=x,st.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=dsum;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,lu[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
        <category>csp</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>csp</tag>
        <tag>图论</tag>
        <tag>dfs</tag>
        <tag>欧拉图</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF CSP 201409-4 最优配餐</title>
    <url>/blog/2020/02/11/csp201409-4/</url>
    <content><![CDATA[<h1>CCF CSP 201409-4 最优配餐</h1>
<h2 id="问题描述"><a class="header-anchor" href="#问题描述">♔</a>问题描述</h2>
<p>栋栋最近开了一家餐饮连锁店，提供外卖服务。随着连锁店越来越多，怎么合理的给客户送餐成为了一个急需解决的问题。<a id="more"></a><br>
　　栋栋的连锁店所在的区域可以看成是一个n×n的方格图（如下图所示），方格的格点上的位置上可能包含栋栋的分店（绿色标注）或者客户（蓝色标注），有一些格点是不能经过的（红色标注）。</p>
<p><img src="http://118.190.20.162/RequireFile.do?fid=383qHJjQ" alt="示例图片"></p>
<p>方格图中的线表示可以行走的道路，相邻两个格点的距离为1。栋栋要送餐必须走可以行走的道路，而且不能经过红色标注的点。</p>
<p>送餐的主要成本体现在路上所花的时间，每一份餐每走一个单位的距离需要花费1块钱。每个客户的需求都可以由栋栋的任意分店配送，每个分店没有配送总量的限制。<br>
　　现在你得到了栋栋的客户的需求，请问在最优的送餐方式下，送这些餐需要花费多大的成本。</p>
<h2 id="输入格式"><a class="header-anchor" href="#输入格式">♔</a>输入格式</h2>
<p>输入的第一行包含四个整数n, m, k, d，分别表示方格图的大小、栋栋的分店数量、客户的数量，以及不能经过的点的数量。<br>
　　接下来m行，每行两个整数xi, yi，表示栋栋的一个分店在方格图中的横坐标和纵坐标。<br>
　　接下来k行，每行三个整数xi, yi, ci，分别表示每个客户在方格图中的横坐标、纵坐标和订餐的量。（注意，可能有多个客户在方格图中的同一个位置）<br>
　　接下来d行，每行两个整数，分别表示每个不能经过的点的横坐标和纵坐标。</p>
<h2 id="输出格式"><a class="header-anchor" href="#输出格式">♔</a>输出格式</h2>
<p>输出一个整数，表示最优送餐方式下所需要花费的成本。</p>
<h2 id="样例输入"><a class="header-anchor" href="#样例输入">♔</a>样例输入</h2>
<p>10 2 3 3<br>
1 1<br>
8 8<br>
1 5 1<br>
2 3 3<br>
6 7 2<br>
1 2<br>
2 2<br>
6 8</p>
<h2 id="样例输出"><a class="header-anchor" href="#样例输出">♔</a>样例输出</h2>
<p>29</p>
<h2 id="评测用例规模与约定"><a class="header-anchor" href="#评测用例规模与约定">♔</a>评测用例规模与约定</h2>
<p>前30%的评测用例满足：1&lt;=n &lt;=20。<br>
　　前60%的评测用例满足：1&lt;=n&lt;=100。<br>
　　所有评测用例都满足：1&lt;=n&lt;=1000，1&lt;=m, k, d&lt;=n^2。可能有多个客户在同一个格点上。每个客户的订餐量不超过1000，每个客户所需要的餐都能被送到。</p>
<h2 id="解题思路"><a class="header-anchor" href="#解题思路">♔</a>解题思路</h2>
<p>​		根据题意可知，我们要求的是送餐需要花费的最小成本，这个问题可以转化为求从各个分店到图上任意一点的最短路。在此我们使用bfs的方法。最开始我采用的是从每一个分店开始，对这个图进行bfs的方法，这个方法在分店数目过多时会浪费大量时间，以至于TLE才得到了80分。然后对这个算法进行优化，多个起点同时对这个图进行bfs，实现方法也很简单，只要在开始前将所有分店都加入到队列中即可。</p>
<p>​		（又及，感觉这个写的好像spfa啊</p>
<p>​		（又及的又及，十年oi一场空，不开long long见祖宗</p>
<h2 id="代码"><a class="header-anchor" href="#代码">♔</a>代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">po</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y,sum;</span><br><span class="line">&#125;;</span><br><span class="line">po fd[<span class="number">1000005</span>],kh[<span class="number">1000005</span>];</span><br><span class="line"><span class="keyword">int</span> tu[<span class="number">1005</span>][<span class="number">1005</span>],dis[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> fx[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> n,m,k,d;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="built_in">queue</span>&lt;po&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dis[fd[i].x][fd[i].y]=<span class="number">0</span>;</span><br><span class="line">		tu[fd[i].x][fd[i].y]=<span class="number">1</span>;</span><br><span class="line">		po t;</span><br><span class="line">		t.x=fd[i].x,t.y=fd[i].y;</span><br><span class="line">		q.push(t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		po u=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		tu[u.x][u.y]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(u.x+fx[i][<span class="number">0</span>]&lt;=<span class="number">0</span> || u.x+fx[i][<span class="number">0</span>]&gt;n || u.y+fx[i][<span class="number">1</span>]&lt;=<span class="number">0</span> || u.y+fx[i][<span class="number">1</span>]&gt;n || tu[u.x+fx[i][<span class="number">0</span>]][u.y+fx[i][<span class="number">1</span>]]==<span class="number">-1</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(dis[u.x+fx[i][<span class="number">0</span>]][u.y+fx[i][<span class="number">1</span>]]&gt;dis[u.x][u.y]+<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				dis[u.x+fx[i][<span class="number">0</span>]][u.y+fx[i][<span class="number">1</span>]]=dis[u.x][u.y]+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(!tu[u.x+fx[i][<span class="number">0</span>]][u.y+fx[i][<span class="number">1</span>]])</span><br><span class="line">				&#123;</span><br><span class="line">					po v;</span><br><span class="line">					v.x=u.x+fx[i][<span class="number">0</span>];</span><br><span class="line">					v.y=u.y+fx[i][<span class="number">1</span>];</span><br><span class="line">					q.push(v);</span><br><span class="line">					tu[u.x+fx[i][<span class="number">0</span>]][u.y+fx[i][<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;k,&amp;d);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++) dis[i][j]=<span class="number">0x7fffffff</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;fd[i].x,&amp;fd[i].y);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=k;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;kh[i].x,&amp;kh[i].y,&amp;kh[i].sum);</span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=d;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">		tu[x][y]=<span class="number">-1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	bfs();</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ans+=(ll)(dis[kh[i].x][kh[i].y]*kh[i].sum);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
        <category>csp</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>csp</tag>
        <tag>图论</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF CSP 201509-4 高速公路</title>
    <url>/blog/2020/02/11/csp201509-4/</url>
    <content><![CDATA[<h1>CCF CSP 201509-4 高速公路</h1>
<h2 id="问题描述"><a class="header-anchor" href="#问题描述">♔</a>问题描述</h2>
<p>某国有<em>n</em>个城市，为了使得城市间的交通更便利，该国国王打算在城市之间修一些高速公路，由于经费限制，国王打算第一阶段先在部分城市之间修一些单向的高速公路。<br>
　　现在，大臣们帮国王拟了一个修高速公路的计划。看了计划后，国王发现，有些城市之间可以通过高速公路直接（不经过其他城市）或间接（经过一个或多个其他城市）到达，而有的却不能。如果城市A可以通过高速公路到达城市B，而且城市B也可以通过高速公路到达城市A，则这两个城市被称为便利城市对。<br>
　　国王想知道，在大臣们给他的计划中，有多少个便利城市对。<a id="more"></a></p>
<h2 id="输入格式"><a class="header-anchor" href="#输入格式">♔</a>输入格式</h2>
<p>输入的第一行包含两个整数<em>n</em>, <em>m</em>，分别表示城市和单向高速公路的数量。<br>
　　接下来<em>m</em>行，每行两个整数<em>a</em>, <em>b</em>，表示城市<em>a</em>有一条单向的高速公路连向城市<em>b</em>。</p>
<h2 id="输出格式"><a class="header-anchor" href="#输出格式">♔</a>输出格式</h2>
<p>输出一行，包含一个整数，表示便利城市对的数量。</p>
<h2 id="样例输入"><a class="header-anchor" href="#样例输入">♔</a>样例输入</h2>
<p>5 5<br>
1 2<br>
2 3<br>
3 4<br>
4 2<br>
3 5</p>
<h2 id="样例输出"><a class="header-anchor" href="#样例输出">♔</a>样例输出</h2>
<p>3</p>
<h2 id="样例说明"><a class="header-anchor" href="#样例说明">♔</a>样例说明</h2>
<p><img src="http://118.190.20.162/RequireFile.do?fid=4HG9GgbF" alt="img"></p>
<p>​		城市间的连接如图所示。有3个便利城市对，它们分别是(2, 3), (2, 4), (3, 4)，请注意(2, 3)和(3, 2)看成同一个便利城市对。</p>
<h2 id="评测用例规模与约定"><a class="header-anchor" href="#评测用例规模与约定">♔</a>评测用例规模与约定</h2>
<p>前30%的评测用例满足1 ≤ <em>n</em> ≤ 100, 1 ≤ <em>m</em> ≤ 1000；<br>
　　前60%的评测用例满足1 ≤ <em>n</em> ≤ 1000, 1 ≤ <em>m</em> ≤ 10000；<br>
　　所有评测用例满足1 ≤ <em>n</em> ≤ 10000, 1 ≤ <em>m</em> ≤ 100000。</p>
<h2 id="解题思路"><a class="header-anchor" href="#解题思路">♔</a>解题思路</h2>
<p>​		根据题意可知，我们只要分别求出图中各个连通分量所包含的节点数目，即可分别计算出便利城市对数，然后将各个连通分量的便利城市对数相加就可以了。题目不难，只要套个Tarjan板子就可以做，但迷惑的是我的板子好像是错的？？？我的模板是这么写的，只能得80分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(dfn[v] &amp;&amp; dfn[v]&lt;low[u]) low[u]=dfn[v];</span><br></pre></td></tr></table></figure>
<p>​		后来找的板子是这样的，可以a掉</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(visit[v] &amp;&amp; dfn[v]&lt;low[u]) low[u]=dfn[v];</span><br></pre></td></tr></table></figure>
<p>​</p>
<h2 id="代码"><a class="header-anchor" href="#代码">♔</a>代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dfn[<span class="number">100005</span>],low[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> m,n,times;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[<span class="number">100005</span>],visit[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> top,cnt,sum[<span class="number">100005</span>],icnt,isum[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> adj[<span class="number">100005</span>],nxt[<span class="number">200005</span>],to[<span class="number">200005</span>],ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	nxt[++ecnt]=adj[x],adj[x]=ecnt,to[ecnt]=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	visit[u]=<span class="number">1</span>,<span class="built_in">stack</span>[++top]=u;</span><br><span class="line">	dfn[u]=low[u]=++times;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=adj[u];i;i=nxt[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=to[i];</span><br><span class="line">		<span class="keyword">if</span>(!dfn[v])</span><br><span class="line">		&#123;</span><br><span class="line">			Tarjan(v);</span><br><span class="line">			low[u]=min(low[u],low[v]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(visit[v] &amp;&amp; dfn[v]&lt;low[u]) low[u]=dfn[v];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v;</span><br><span class="line">		icnt++; </span><br><span class="line">		visit[u]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(v=<span class="built_in">stack</span>[top--],isum[icnt]++,v!=u) visit[v]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">int</span> a,b;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">		adde(a,b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">		<span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=icnt;i++) </span><br><span class="line">		ans+=isum[i]*(isum[i]<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
        <category>csp</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>csp</tag>
        <tag>图论</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>Python——正则表达式(中)</title>
    <url>/blog/2019/08/19/python-re%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h1>正则表达式（中）</h1>
<h2 id="re库的基本使用"><a class="header-anchor" href="#re库的基本使用">♔</a>re库的基本使用</h2>
<p>re库是python的标准库，不需要进行额外的安装，主要用于字符串匹配。调用方法也特别简单，只需要</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>re库采用raw string类型来表示正则表达式，表示为：r’text’。相较于string类型，raw string就是不包含转义符的字符串，当然也可以用string类型来 表示正则表达式，但是特别的繁琐。</p>
<p>Re库主要功能函数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>re.search()</td>
<td>在一 个 字符串中搜索匹配正则表达式的第一个位置， 返回match对象</td>
</tr>
<tr>
<td>re.match()</td>
<td>从一个字符串的开始位置起匹配正则表达式，返回match对象</td>
</tr>
<tr>
<td>re.findall()</td>
<td>搜索字符串，以列表类型返回全部能匹配的子串</td>
</tr>
<tr>
<td>re.splito()</td>
<td>将一个字符串按照正则表达式匹配结果进行分割，返回列表类型</td>
</tr>
<tr>
<td>re.finditer()</td>
<td>搜索字符串，返回一个匹配结果的选代类型，每个选代元素是match对象</td>
</tr>
<tr>
<td>re.sub()</td>
<td>在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Python</category>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Python——正则表达式(上)</title>
    <url>/blog/2019/08/18/python-re/</url>
    <content><![CDATA[<h1>正则表达式（上）</h1>
<h2 id="零-什么是正则表达式"><a class="header-anchor" href="#零-什么是正则表达式">♔</a>零 什么是正则表达式</h2>
<p>正则表达式（<strong>r</strong>egular <strong>e</strong>xpression，简称<strong>RE</strong>），是用来简洁表达一组字符串的表达式。这种针对字符串表达“简洁”和“特征”思想的工具可以非常简单的表达一组字符串的特征，起到了“一行胜千言”的效果。在诸如爬虫等需要对字符串进行处理的地方应用广泛。<a id="more"></a></p>
<h2 id="壹-正则表达式的作用"><a class="header-anchor" href="#壹-正则表达式的作用">♔</a>壹 正则表达式的作用</h2>
<ul>
<li>表达文本类型的特征</li>
<li>同时查找或替换一组字符串</li>
<li>匹配字符串的全部或部分</li>
</ul>
<h2 id="贰-常用操作符"><a class="header-anchor" href="#贰-常用操作符">♔</a>贰 常用操作符</h2>
<p>因为正则表达式由字符和操作符构成，故应了解常用操作符及其用法。</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>表示任何单个字符</td>
<td></td>
</tr>
<tr>
<td>[]</td>
<td>字符集，对单个字符给出取值范围</td>
<td>[abc]表示a、b、c，[a-z]表示a到z任意单个字符</td>
</tr>
<tr>
<td>[^ ]</td>
<td>非字符集，对单个字符给出排除范围</td>
<td>[^abc]表示非a或b或c的单个字符</td>
</tr>
<tr>
<td>*</td>
<td>前一个字符0次或无限次扩展</td>
<td>abc*表示ab、abc、abcc、abccc等</td>
</tr>
<tr>
<td>+</td>
<td>前一个字符1次或无限次扩展</td>
<td>abc+表示abc、abcc、abccc等</td>
</tr>
<tr>
<td>?</td>
<td>前一个字符0次或1次扩展</td>
<td>abc?表示ab、abc等</td>
</tr>
<tr>
<td>|</td>
<td>左右表达式任意一个</td>
<td>abc|def表示abc或def</td>
</tr>
<tr>
<td>{m}</td>
<td>扩展前一个字符m次</td>
<td>ab{2}表示abbc</td>
</tr>
<tr>
<td>{m,n}</td>
<td>扩展前一个字符m到n次（含n）</td>
<td>ab{1,2}表示abc、abbc</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串开头</td>
<td></td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串结尾</td>
<td></td>
</tr>
<tr>
<td>()</td>
<td>分组标记（内部只能使用|操作符）</td>
<td></td>
</tr>
<tr>
<td>\d</td>
<td>数字，等价于[0-9]</td>
<td></td>
</tr>
<tr>
<td>\w</td>
<td>单词字符，等价于[A-Za-z0-9_]</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="叁-经典正则语法实例"><a class="header-anchor" href="#叁-经典正则语法实例">♔</a>叁 经典正则语法实例</h2>
<p>下面看几个实例（比较简单或前面已经出现过的就不再赘述）</p>
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>对应字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>\w{0,31}$</td>
<td>合法的变量</td>
</tr>
<tr>
<td>[\u4e00-\u9fa5]</td>
<td>中文字符</td>
</tr>
<tr>
<td>(([1-9]?\d|1\d{2}|2[0-4]\d|25[0-5]).){3}(([1-9]?\d|1\d{2}|2[0-4]\d|25[0-5]).)</td>
<td>ip地址</td>
</tr>
</tbody>
</table>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>A-Za-z <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Python</category>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫——requests库入门（上）</title>
    <url>/blog/2019/08/17/pypc1/</url>
    <content><![CDATA[<h1>requests库入门（上）</h1>
<h2 id="零-前言"><a class="header-anchor" href="#零-前言">♔</a>零 前言</h2>
<p>本系列是pytho爬虫的学习笔记，根据<a href="https://www.icourse163.org/course/BIT-1001870001" target="_blank" rel="noopener">北京理工大学 Python网络爬虫与信息提取mooc</a>整理。本文主要阐述了requests库的基本知识以及爬取页面的通用框架。<a id="more"></a></p>
<h2 id="壹-requests库的安装"><a class="header-anchor" href="#壹-requests库的安装">♔</a>壹 requests库的安装</h2>
<p><strong>pip是个好东西</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure>
<h2 id="贰-requests库中的方法"><a class="header-anchor" href="#贰-requests库中的方法">♔</a>贰 requests库中的方法</h2>
<h3 id="0-七种方法："><a class="header-anchor" href="#0-七种方法：">♔</a>0. 七种方法：</h3>
<ol>
<li>requests.request()</li>
<li>requests.get()</li>
<li>requests.head()</li>
<li>requests.post()</li>
<li>requests.put()</li>
<li>requests.patch()</li>
<li>requests.delete()</li>
</ol>
<p><strong>所有方法本质上都是Requests方法</strong></p>
<h3 id="1-get（）方法"><a class="header-anchor" href="#1-get（）方法">♔</a>1. get（）方法</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r=requests.get(url,params=<span class="literal">None</span>,**kwargs)</span><br><span class="line"><span class="comment">#获得网页</span></span><br><span class="line"><span class="comment">#(第一个参数必选，第二个第三个可不选)</span></span><br></pre></td></tr></table></figure>
<h2 id="叁-requests库中两个重要对象"><a class="header-anchor" href="#叁-requests库中两个重要对象">♔</a>叁 requests库中两个重要对象</h2>
<h3 id="0-response对象及request对象"><a class="header-anchor" href="#0-response对象及request对象">♔</a>0.response对象及request对象</h3>
<p>在</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r=requests.get()</span><br></pre></td></tr></table></figure>
<p>中，等号前的部分，称为response对象（其中包含服务器返回的所有信息，也包含request请求的所有信息）；等号后的部分称为request对象。</p>
<h3 id="1-Response对象的属性"><a class="header-anchor" href="#1-Response对象的属性">♔</a>1. Response对象的属性</h3>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>r.status_code</td>
<td>HTTP请求返回的状态，200成功，404失败</td>
</tr>
<tr>
<td>r.text</td>
<td>HTTP响应内容的字符串形式，即url的页面内容</td>
</tr>
<tr>
<td>r.encoding</td>
<td>从HTTP header中猜测的响应内容的编码方式</td>
</tr>
<tr>
<td>r.apparent_encoding</td>
<td>从内容分析出的响应内容编码方式（备选编码方式）</td>
</tr>
<tr>
<td>r.content</td>
<td>HTTP响应内容的二进制形式</td>
</tr>
</tbody>
</table>
<h2 id="肆-requests库的异常"><a class="header-anchor" href="#肆-requests库的异常">♔</a>肆 requests库的异常</h2>
<table>
<thead>
<tr>
<th>异常</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>requests.ConnectionError</td>
<td>网络连接错误异常，如DNS查询失败、拒绝连接等</td>
</tr>
<tr>
<td>requests.HTTPError</td>
<td>HTTP错误异常</td>
</tr>
<tr>
<td>requests.URLRequired</td>
<td>URL缺失异常</td>
</tr>
<tr>
<td>requests.TooManyRedirects</td>
<td>超过最大重定向次数，产生重定向异常</td>
</tr>
<tr>
<td>requests.ConnectionTimeout</td>
<td>连接远程服务器超时异常</td>
</tr>
<tr>
<td>requests.Timeout</td>
<td>请求URL超时，产生超时异常</td>
</tr>
<tr>
<td>r.raise_for_statues()</td>
<td>如果不是200，产生异常 requests.HTTPError</td>
</tr>
</tbody>
</table>
<h2 id="伍-爬取页面通用框架"><a class="header-anchor" href="#伍-爬取页面通用框架">♔</a>伍 爬取页面通用框架</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span></span></span><br><span class="line"><span class="function">   <span class="title">try</span>:</span></span><br><span class="line">      r=requests.get(url)</span><br><span class="line">      r.raise_for_statues() <span class="comment">#如果状态码不是200，产生HTTPError异常</span></span><br><span class="line">      r.encoding=r.apparent_encoding <span class="comment">#替换编码方式</span></span><br><span class="line">      <span class="keyword">return</span> r.text</span><br><span class="line">   expect:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Error"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">   url=<span class="string">"http://www.baidu.com"</span></span><br><span class="line">   print(getHTMLText(url))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
        <category>Python</category>
        <category>爬虫</category>
        <category>requests库</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>requests库</tag>
      </tags>
  </entry>
  <entry>
    <title>重新开始</title>
    <url>/blog/2019/08/13/restart/</url>
    <content><![CDATA[<h1>如题</h1>
<a id="more"></a>]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
